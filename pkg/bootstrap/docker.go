package bootstrap

import (
	"os/exec"
	"regexp"
	"strings"

	"orchestrator/pkg/build"
)

// DockerfileConfig holds configuration for Dockerfile generation
type DockerfileConfig struct {
	GoVersion    string
	BaseImage    string
	BuildImage   string
	WorkDir      string
	ExposedPorts []string
	BuildArgs    []string
	RunCommands  []string
	EntryPoint   []string
	Reproducible bool
}

// detectGoVersion detects the Go version from the system
func (g *ArtifactGenerator) detectGoVersion() (string, error) {
	// Try to get Go version from go command
	cmd := exec.Command("go", "version")
	output, err := cmd.Output()
	if err != nil {
		g.logger.Warn("Failed to detect Go version: %v", err)
		return "1.21", nil // Default fallback
	}

	// Parse output like "go version go1.21.5 darwin/arm64"
	versionStr := string(output)
	re := regexp.MustCompile(`go(\d+\.\d+)`)
	matches := re.FindStringSubmatch(versionStr)
	if len(matches) >= 2 {
		return matches[1], nil
	}

	g.logger.Warn("Could not parse Go version from: %s", versionStr)
	return "1.21", nil // Default fallback
}

// detectNodeVersion detects the Node.js version from the system
func (g *ArtifactGenerator) detectNodeVersion() (string, error) {
	cmd := exec.Command("node", "--version")
	output, err := cmd.Output()
	if err != nil {
		g.logger.Warn("Failed to detect Node version: %v", err)
		return "18", nil // Default fallback
	}

	// Parse output like "v18.17.0"
	versionStr := strings.TrimSpace(string(output))
	re := regexp.MustCompile(`v(\d+)`)
	matches := re.FindStringSubmatch(versionStr)
	if len(matches) >= 2 {
		return matches[1], nil
	}

	g.logger.Warn("Could not parse Node version from: %s", versionStr)
	return "18", nil // Default fallback
}

// detectPythonVersion detects the Python version from the system
func (g *ArtifactGenerator) detectPythonVersion() (string, error) {
	cmd := exec.Command("python3", "--version")
	output, err := cmd.Output()
	if err != nil {
		g.logger.Warn("Failed to detect Python version: %v", err)
		return "3.11", nil // Default fallback
	}

	// Parse output like "Python 3.11.5"
	versionStr := string(output)
	re := regexp.MustCompile(`Python (\d+\.\d+)`)
	matches := re.FindStringSubmatch(versionStr)
	if len(matches) >= 2 {
		return matches[1], nil
	}

	g.logger.Warn("Could not parse Python version from: %s", versionStr)
	return "3.11", nil // Default fallback
}

// generateDockerignore generates a .dockerignore file based on the backend
func (g *ArtifactGenerator) GenerateDockerignore(backend build.BuildBackend) error {
	var content strings.Builder

	// Common ignores
	content.WriteString(`# Generated by Claude Code Bootstrap
# Common ignores
.git
.gitignore
.maestro
node_modules
.env
.env.local
.DS_Store
Thumbs.db
*.log
*.tmp
*.swp
*.swo
*~

# Build artifacts
bin/
build/
dist/
out/

# IDE files
.vscode/
.idea/
*.iml
*.sublime-*

# OS files
.DS_Store
Thumbs.db

`)

	// Backend-specific ignores
	switch backend.Name() {
	case "go":
		content.WriteString(`# Go-specific ignores
*.exe
*.exe~
*.dll
*.so
*.dylib
*.test
*.out
coverage.txt
go.work
go.work.sum

`)
	case "node":
		content.WriteString(`# Node.js-specific ignores
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.npm
.yarn-integrity
.next/
coverage/

`)
	case "python":
		content.WriteString(`# Python-specific ignores
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
pip-wheel-metadata/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
.pytest_cache/
.coverage
htmlcov/
.tox/
.nox/
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.venv/
ENV/
env/
venv/

`)
	}

	return g.writeFile(".dockerignore", content.String())
}
