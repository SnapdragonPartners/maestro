package bootstrap

import (
	"context"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"orchestrator/pkg/logx"
)

// GitManager handles Git operations for bootstrap branch management.
type GitManager struct {
	logger      *logx.Logger
	projectRoot string
}

// NewGitManager creates a new Git manager.
func NewGitManager(projectRoot string, logger *logx.Logger) *GitManager {
	return &GitManager{
		projectRoot: projectRoot,
		logger:      logger,
	}
}

// IsGitRepository checks if the project root is a Git repository.
func (g *GitManager) IsGitRepository() bool {
	gitDir := filepath.Join(g.projectRoot, ".git")
	if info, err := os.Stat(gitDir); err == nil {
		return info.IsDir()
	}

	// Check if we're in a Git worktree.
	if _, err := g.runGitCommand("rev-parse", "--git-dir"); err == nil {
		return true
	}

	return false
}

// CreateBranch creates a new branch for bootstrap artifacts.
func (g *GitManager) CreateBranch(ctx context.Context, branchName string) error {
	g.logger.Info("Creating bootstrap branch: %s", branchName)

	// Check if branch already exists.
	if g.branchExists(branchName) {
		g.logger.Info("Branch %s already exists, switching to it", branchName)
		if err := g.runGitCommandWithContext(ctx, "checkout", branchName); err != nil {
			return fmt.Errorf("failed to checkout existing branch %s: %w", branchName, err)
		}
		return nil
	}

	// Create and checkout new branch.
	if err := g.runGitCommandWithContext(ctx, "checkout", "-b", branchName); err != nil {
		return fmt.Errorf("failed to create branch %s: %w", branchName, err)
	}

	g.logger.Info("Created and switched to branch: %s", branchName)
	return nil
}

// CommitArtifacts commits the bootstrap artifacts to the current branch.
func (g *GitManager) CommitArtifacts(ctx context.Context, artifacts []string, message string) error {
	g.logger.Info("Committing %d bootstrap artifacts", len(artifacts))

	// Add all artifacts to staging.
	for _, artifact := range artifacts {
		if err := g.runGitCommandWithContext(ctx, "add", artifact); err != nil {
			return fmt.Errorf("failed to add %s to staging: %w", artifact, err)
		}
	}

	// Check if there are any changes to commit.
	if empty, err := g.isStagingEmpty(); err != nil {
		return fmt.Errorf("failed to check staging area: %w", err)
	} else if empty {
		g.logger.Info("No changes to commit")
		return nil
	}

	// Commit changes.
	commitMessage := fmt.Sprintf("%s\n\nGenerated by Claude Code Bootstrap\n\nFiles created:\n%s",
		message, strings.Join(artifacts, "\n"))

	if err := g.runGitCommandWithContext(ctx, "commit", "-m", commitMessage); err != nil {
		return fmt.Errorf("failed to commit artifacts: %w", err)
	}

	g.logger.Info("Committed bootstrap artifacts with message: %s", message)
	return nil
}

// MergeBranch merges the bootstrap branch into the base branch.
func (g *GitManager) MergeBranch(ctx context.Context, sourceBranch, targetBranch string) error {
	g.logger.Info("Merging %s into %s", sourceBranch, targetBranch)

	// Ensure we're on the target branch.
	currentBranch, err := g.getCurrentBranch()
	if err != nil {
		return fmt.Errorf("failed to get current branch: %w", err)
	}

	if currentBranch != targetBranch {
		if err := g.runGitCommandWithContext(ctx, "checkout", targetBranch); err != nil {
			return fmt.Errorf("failed to checkout target branch %s: %w", targetBranch, err)
		}
	}

	// Merge the source branch.
	if err := g.runGitCommandWithContext(ctx, "merge", sourceBranch, "--no-ff", "-m",
		fmt.Sprintf("Merge bootstrap branch %s", sourceBranch)); err != nil {
		return fmt.Errorf("failed to merge %s into %s: %w", sourceBranch, targetBranch, err)
	}

	g.logger.Info("Successfully merged %s into %s", sourceBranch, targetBranch)
	return nil
}

// DeleteBranch deletes the specified branch.
func (g *GitManager) DeleteBranch(ctx context.Context, branchName string) error {
	g.logger.Info("Deleting branch: %s", branchName)

	// Ensure we're not on the branch we're trying to delete.
	currentBranch, err := g.getCurrentBranch()
	if err != nil {
		return fmt.Errorf("failed to get current branch: %w", err)
	}

	if currentBranch == branchName {
		// Switch to main or master.
		targetBranch := "main"
		if g.branchExists("master") && !g.branchExists("main") {
			targetBranch = "master"
		}

		if err := g.runGitCommandWithContext(ctx, "checkout", targetBranch); err != nil {
			return fmt.Errorf("failed to checkout %s before deleting %s: %w", targetBranch, branchName, err)
		}
	}

	// Delete the branch.
	if err := g.runGitCommandWithContext(ctx, "branch", "-d", branchName); err != nil {
		return fmt.Errorf("failed to delete branch %s: %w", branchName, err)
	}

	g.logger.Info("Deleted branch: %s", branchName)
	return nil
}

// GetStatus returns the current Git status.
func (g *GitManager) GetStatus() (map[string]interface{}, error) {
	status := make(map[string]interface{})

	// Check if it's a Git repository.
	status["is_git_repo"] = g.IsGitRepository()
	if !g.IsGitRepository() {
		return status, nil
	}

	// Get current branch.
	if branch, err := g.getCurrentBranch(); err == nil {
		status["current_branch"] = branch
	}

	// Get repository status.
	if output, err := g.runGitCommand("status", "--porcelain"); err == nil {
		status["has_changes"] = strings.TrimSpace(output) != ""
	}

	// Get last commit.
	if output, err := g.runGitCommand("log", "-1", "--oneline"); err == nil {
		status["last_commit"] = strings.TrimSpace(output)
	}

	return status, nil
}

// Helper methods.

// branchExists checks if a branch exists.
func (g *GitManager) branchExists(branchName string) bool {
	_, err := g.runGitCommand("show-ref", "--verify", "--quiet", "refs/heads/"+branchName)
	return err == nil
}

// getCurrentBranch returns the current branch name.
func (g *GitManager) getCurrentBranch() (string, error) {
	output, err := g.runGitCommand("rev-parse", "--abbrev-ref", "HEAD")
	if err != nil {
		return "", err
	}
	return strings.TrimSpace(output), nil
}

// isStagingEmpty checks if the staging area is empty.
func (g *GitManager) isStagingEmpty() (bool, error) {
	output, err := g.runGitCommand("diff", "--cached", "--name-only")
	if err != nil {
		return false, err
	}
	return strings.TrimSpace(output) == "", nil
}

// runGitCommand runs a Git command and returns its output.
func (g *GitManager) runGitCommand(args ...string) (string, error) {
	cmd := exec.Command("git", args...)
	cmd.Dir = g.projectRoot

	output, err := cmd.CombinedOutput()
	if err != nil {
		return "", fmt.Errorf("git %s failed: %w\nOutput: %s", strings.Join(args, " "), err, output)
	}

	return string(output), nil
}

// runGitCommandWithContext runs a Git command with context and returns its output.
func (g *GitManager) runGitCommandWithContext(ctx context.Context, args ...string) error {
	cmd := exec.CommandContext(ctx, "git", args...)
	cmd.Dir = g.projectRoot

	g.logger.Debug("Running git command: %s", strings.Join(args, " "))

	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("git %s failed: %w\nOutput: %s", strings.Join(args, " "), err, output)
	}

	return nil
}

// ConfigureUnionMerge configures union merge strategy for build files.
func (g *GitManager) ConfigureUnionMerge(ctx context.Context) error {
	g.logger.Info("Configuring union merge strategy for build files")

	// Configure union merge driver.
	if err := g.runGitCommandWithContext(ctx, "config", "merge.union.driver", "true"); err != nil {
		return fmt.Errorf("failed to configure union merge driver: %w", err)
	}

	g.logger.Info("Union merge strategy configured successfully")
	return nil
}

// EnsureGitignore ensures that bootstrap artifacts are properly ignored.
func (g *GitManager) EnsureGitignore(ctx context.Context) error {
	gitignorePath := filepath.Join(g.projectRoot, ".gitignore")

	// Check if .gitignore exists.
	if _, err := os.Stat(gitignorePath); os.IsNotExist(err) {
		g.logger.Info(".gitignore does not exist, will be created by bootstrap")
		return nil
	}

	// Read existing .gitignore.
	content, err := os.ReadFile(gitignorePath)
	if err != nil {
		return fmt.Errorf("failed to read .gitignore: %w", err)
	}

	gitignoreContent := string(content)

	// Add bootstrap-specific ignores if they don't exist.
	bootstrapIgnores := []string{
		"# Bootstrap artifacts",
		"agent.mk.backup",
		".bootstrap-cache/",
	}

	var needsUpdate bool
	for _, ignore := range bootstrapIgnores {
		if !strings.Contains(gitignoreContent, ignore) {
			gitignoreContent += "\n" + ignore
			needsUpdate = true
		}
	}

	if needsUpdate {
		if err := os.WriteFile(gitignorePath, []byte(gitignoreContent), 0644); err != nil {
			return fmt.Errorf("failed to update .gitignore: %w", err)
		}
		g.logger.Info("Updated .gitignore with bootstrap ignores")
	}

	return nil
}

// Clone clones a Git repository to the project root.
func (g *GitManager) Clone(ctx context.Context, repoURL string) error {
	g.logger.Info("Cloning repository: %s", repoURL)

	// Ensure the parent directory exists.
	if err := os.MkdirAll(filepath.Dir(g.projectRoot), 0755); err != nil {
		return fmt.Errorf("failed to create parent directory: %w", err)
	}

	// Clone the repository.
	cmd := exec.CommandContext(ctx, "git", "clone", repoURL, g.projectRoot)
	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("git clone failed: %w\nOutput: %s", err, string(output))
	}

	g.logger.Info("Successfully cloned repository to: %s", g.projectRoot)
	return nil
}
