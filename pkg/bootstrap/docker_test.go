package bootstrap

import (
	"context"
	"io"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"orchestrator/pkg/build"
)

// Mock build backend for testing
type mockBuildBackend struct {
	name string
}

func (m *mockBuildBackend) Name() string {
	return m.name
}

func (m *mockBuildBackend) Detect(root string) bool {
	return true
}

func (m *mockBuildBackend) Build(ctx context.Context, root string, stream io.Writer) error {
	return nil
}

func (m *mockBuildBackend) Test(ctx context.Context, root string, stream io.Writer) error {
	return nil
}

func (m *mockBuildBackend) Lint(ctx context.Context, root string, stream io.Writer) error {
	return nil
}

func (m *mockBuildBackend) Run(ctx context.Context, root string, args []string, stream io.Writer) error {
	return nil
}

func (m *mockBuildBackend) GetDockerImage(root string) string {
	// Return a default image for mock backends
	return "ubuntu:22.04"
}

func TestDockerfileGeneration(t *testing.T) {
	tempDir := t.TempDir()

	config := DefaultConfig()
	generator := NewArtifactGenerator(tempDir, config)

	testCases := []struct {
		name          string
		backend       build.BuildBackend
		expectedParts []string
		expectError   bool
	}{
		{
			name:    "Go backend",
			backend: &mockBuildBackend{name: "go"},
			expectedParts: []string{
				"FROM golang:",
				"Multi-stage build for Go application",
				"go mod download && go mod verify",
				"CGO_ENABLED=0 GOOS=linux go build",
				"FROM alpine:latest",
				"USER appuser",
				"EXPOSE 8080",
				"HEALTHCHECK",
			},
			expectError: false,
		},
		{
			name:    "Python backend",
			backend: &mockBuildBackend{name: "python"},
			expectedParts: []string{
				"FROM python:",
				"PYTHONUNBUFFERED=1",
				"pip install --no-cache-dir",
				"requirements.txt",
				"USER appuser",
				"EXPOSE 8000",
				"HEALTHCHECK",
			},
			expectError: false,
		},
		{
			name:    "Node backend",
			backend: &mockBuildBackend{name: "node"},
			expectedParts: []string{
				"FROM node:",
				"NODE_ENV=production",
				"npm ci --only=production",
				"package*.json",
				"USER appuser",
				"EXPOSE 3000",
				"HEALTHCHECK",
			},
			expectError: false,
		},
		{
			name:    "Unknown backend",
			backend: &mockBuildBackend{name: "unknown"},
			expectedParts: []string{
				"FROM alpine:latest",
				"USER appuser",
				"No Dockerfile template for backend: unknown",
			},
			expectError: false,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Generate Dockerfile
			err := generator.GenerateDockerfile(tc.backend)

			if tc.expectError && err == nil {
				t.Error("Expected error but got none")
			}

			if !tc.expectError && err != nil {
				t.Errorf("Unexpected error: %v", err)
			}

			if !tc.expectError {
				// Check that file was created
				dockerfilePath := filepath.Join(tempDir, "Dockerfile")
				content, err := os.ReadFile(dockerfilePath)
				if err != nil {
					t.Fatalf("Failed to read Dockerfile: %v", err)
				}

				dockerfileContent := string(content)

				// Check for expected parts
				for _, part := range tc.expectedParts {
					if !strings.Contains(dockerfileContent, part) {
						t.Errorf("Expected Dockerfile to contain %q, but it didn't.\nContent:\n%s", part, dockerfileContent)
					}
				}

				// Check that it's properly formatted
				if !strings.HasPrefix(dockerfileContent, "# Generated by Claude Code Bootstrap") {
					t.Error("Expected Dockerfile to start with generated comment")
				}
			}
		})
	}
}

func TestDockerignoreGeneration(t *testing.T) {
	tempDir := t.TempDir()

	config := DefaultConfig()
	generator := NewArtifactGenerator(tempDir, config)

	testCases := []struct {
		name          string
		backend       build.BuildBackend
		expectedParts []string
		expectError   bool
	}{
		{
			name:    "Go backend",
			backend: &mockBuildBackend{name: "go"},
			expectedParts: []string{
				"# Generated by Claude Code Bootstrap",
				".git",
				"node_modules",
				"*.exe",
				"*.dll",
				"*.test",
				"go.work",
			},
			expectError: false,
		},
		{
			name:    "Python backend",
			backend: &mockBuildBackend{name: "python"},
			expectedParts: []string{
				"# Generated by Claude Code Bootstrap",
				"__pycache__/",
				"*.py[cod]",
				".venv/",
				"*.egg-info/",
			},
			expectError: false,
		},
		{
			name:    "Node backend",
			backend: &mockBuildBackend{name: "node"},
			expectedParts: []string{
				"# Generated by Claude Code Bootstrap",
				"node_modules/",
				"npm-debug.log",
				"yarn-error.log",
				".next/",
			},
			expectError: false,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Generate .dockerignore
			err := generator.GenerateDockerignore(tc.backend)

			if tc.expectError && err == nil {
				t.Error("Expected error but got none")
			}

			if !tc.expectError && err != nil {
				t.Errorf("Unexpected error: %v", err)
			}

			if !tc.expectError {
				// Check that file was created
				dockerignorePath := filepath.Join(tempDir, ".dockerignore")
				content, err := os.ReadFile(dockerignorePath)
				if err != nil {
					t.Fatalf("Failed to read .dockerignore: %v", err)
				}

				dockerignoreContent := string(content)

				// Check for expected parts
				for _, part := range tc.expectedParts {
					if !strings.Contains(dockerignoreContent, part) {
						t.Errorf("Expected .dockerignore to contain %q, but it didn't.\nContent:\n%s", part, dockerignoreContent)
					}
				}
			}
		})
	}
}

func TestVersionDetection(t *testing.T) {
	tempDir := t.TempDir()
	config := DefaultConfig()
	generator := NewArtifactGenerator(tempDir, config)

	t.Run("Go version detection", func(t *testing.T) {
		version, err := generator.detectGoVersion()
		if err != nil {
			t.Errorf("Go version detection failed: %v", err)
		}

		// Should return a valid version string
		if version == "" {
			t.Error("Expected non-empty version string")
		}

		// Should match pattern like "1.21"
		if !strings.Contains(version, ".") {
			t.Errorf("Expected version to contain dot, got %s", version)
		}
	})

	t.Run("Node version detection", func(t *testing.T) {
		version, err := generator.detectNodeVersion()
		if err != nil {
			t.Errorf("Node version detection failed: %v", err)
		}

		// Should return a valid version string (even if just default)
		if version == "" {
			t.Error("Expected non-empty version string")
		}
	})

	t.Run("Python version detection", func(t *testing.T) {
		version, err := generator.detectPythonVersion()
		if err != nil {
			t.Errorf("Python version detection failed: %v", err)
		}

		// Should return a valid version string (even if just default)
		if version == "" {
			t.Error("Expected non-empty version string")
		}
	})
}

func TestDockerfileReproducibility(t *testing.T) {
	tempDir := t.TempDir()
	config := DefaultConfig()
	generator := NewArtifactGenerator(tempDir, config)

	backend := &mockBuildBackend{name: "go"}

	// Generate Dockerfile twice
	err1 := generator.GenerateDockerfile(backend)
	if err1 != nil {
		t.Fatalf("First generation failed: %v", err1)
	}

	content1, err := os.ReadFile(filepath.Join(tempDir, "Dockerfile"))
	if err != nil {
		t.Fatalf("Failed to read first Dockerfile: %v", err)
	}

	err2 := generator.GenerateDockerfile(backend)
	if err2 != nil {
		t.Fatalf("Second generation failed: %v", err2)
	}

	content2, err := os.ReadFile(filepath.Join(tempDir, "Dockerfile"))
	if err != nil {
		t.Fatalf("Failed to read second Dockerfile: %v", err)
	}

	// Content should be identical (reproducible)
	if string(content1) != string(content2) {
		t.Error("Dockerfile generation is not reproducible")
	}
}

func TestCoreArtifactsIncludeDocker(t *testing.T) {
	tempDir := t.TempDir()
	config := DefaultConfig()
	generator := NewArtifactGenerator(tempDir, config)

	backend := &mockBuildBackend{name: "go"}

	// Generate core artifacts
	artifacts, err := generator.generateCoreArtifacts(context.Background(), backend)
	if err != nil {
		t.Fatalf("Failed to generate core artifacts: %v", err)
	}

	// Check that Dockerfile and .dockerignore are included
	hasDockerfile := false
	hasDockerignore := false

	for _, artifact := range artifacts {
		if artifact == "Dockerfile" {
			hasDockerfile = true
		}
		if artifact == ".dockerignore" {
			hasDockerignore = true
		}
	}

	if !hasDockerfile {
		t.Error("Expected Dockerfile to be included in core artifacts")
	}

	if !hasDockerignore {
		t.Error("Expected .dockerignore to be included in core artifacts")
	}

	// Verify files were actually created
	dockerfilePath := filepath.Join(tempDir, "Dockerfile")
	if _, err := os.Stat(dockerfilePath); os.IsNotExist(err) {
		t.Error("Dockerfile was not created")
	}

	dockerignorePath := filepath.Join(tempDir, ".dockerignore")
	if _, err := os.Stat(dockerignorePath); os.IsNotExist(err) {
		t.Error(".dockerignore was not created")
	}
}
