package bootstrap

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"orchestrator/pkg/build"
	"orchestrator/pkg/logx"
)

// WorkflowGenerator generates GitHub workflow files.
//
//nolint:govet // Simple generator struct, logical grouping preferred
type WorkflowGenerator struct {
	projectRoot string
	logger      *logx.Logger
}

// NewWorkflowGenerator creates a new workflow generator.
func NewWorkflowGenerator(projectRoot string) *WorkflowGenerator {
	return &WorkflowGenerator{
		projectRoot: projectRoot,
		logger:      logx.NewLogger("bootstrap-workflows"),
	}
}

// platformToEcosystem maps platform names to Dependabot ecosystem names.
//
//nolint:gochecknoglobals // Read-only lookup table for ecosystem mapping
var platformToEcosystem = map[string]string{
	"go":     "gomod",
	"node":   "npm",
	"python": "pip",
	"rust":   "cargo",
	"java":   "maven",
}

// GenerateAll generates all workflow files for the detected backend.
func (w *WorkflowGenerator) GenerateAll(backend build.Backend, testTarget string) ([]string, error) {
	var files []string

	// Create .github/workflows directory
	workflowDir := filepath.Join(w.projectRoot, ".github", "workflows")
	if err := os.MkdirAll(workflowDir, 0755); err != nil {
		return nil, fmt.Errorf("failed to create workflows directory: %w", err)
	}

	// Generate dependabot.yml
	if err := w.generateDependabotConfig(backend); err != nil {
		return nil, fmt.Errorf("failed to generate dependabot.yml: %w", err)
	}
	files = append(files, ".github/dependabot.yml")

	// Generate CI workflow with test target
	if err := w.generateCIWorkflow(backend, testTarget); err != nil {
		return nil, fmt.Errorf("failed to generate CI workflow: %w", err)
	}
	files = append(files, ".github/workflows/ci.yml")

	// Generate dependabot auto-merge workflow
	if err := w.generateDependabotAutoMergeWorkflow(); err != nil {
		return nil, fmt.Errorf("failed to generate dependabot auto-merge workflow: %w", err)
	}
	files = append(files, ".github/workflows/dependabot-auto-merge.yml")

	w.logger.Info("Generated %d workflow files", len(files))
	return files, nil
}

// generateDependabotConfig generates .github/dependabot.yml.
func (w *WorkflowGenerator) generateDependabotConfig(backend build.Backend) error {
	ecosystem, ok := platformToEcosystem[backend.Name()]
	if !ok {
		w.logger.Warn("No dependabot ecosystem mapping for backend %s, skipping dependabot.yml", backend.Name())
		return nil
	}

	content := fmt.Sprintf(`# Generated by Maestro Bootstrap
# Dependabot configuration for automated dependency updates
version: 2
updates:
  - package-ecosystem: "%s"
    directory: "/"
    schedule:
      interval: "weekly"
    open-pull-requests-limit: 10
    commit-message:
      prefix: "deps"
    labels:
      - "dependencies"
      - "automated"
`, ecosystem)

	return w.writeFile(".github/dependabot.yml", content)
}

// generateCIWorkflow generates .github/workflows/ci.yml using the detected test target.
func (w *WorkflowGenerator) generateCIWorkflow(backend build.Backend, testTarget string) error {
	if testTarget == "" {
		testTarget = "make test"
	}

	var setupSteps string
	switch backend.Name() {
	case "go":
		setupSteps = `
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'
          cache: true`
	case "node":
		setupSteps = `
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci`
	case "python":
		setupSteps = `
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version-file: 'pyproject.toml'
          cache: 'pip'

      - name: Install uv
        run: pip install uv

      - name: Install dependencies
        run: uv sync`
	case "rust":
		setupSteps = `
      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy

      - name: Cache cargo
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}`
	default:
		setupSteps = ""
	}

	content := fmt.Sprintf(`# Generated by Maestro Bootstrap
name: CI

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4%s

      - name: Run tests
        run: %s
`, setupSteps, testTarget)

	return w.writeFile(".github/workflows/ci.yml", content)
}

// generateDependabotAutoMergeWorkflow generates the auto-merge workflow for dependabot PRs.
func (w *WorkflowGenerator) generateDependabotAutoMergeWorkflow() error {
	content := `# Generated by Maestro Bootstrap
# Automatically merge Dependabot PRs for patch updates
name: Dependabot Auto-merge

on: pull_request

permissions:
  contents: write
  pull-requests: write

jobs:
  dependabot:
    runs-on: ubuntu-latest
    if: github.actor == 'dependabot[bot]'
    steps:
      - name: Dependabot metadata
        id: metadata
        uses: dependabot/fetch-metadata@v2
        with:
          github-token: "${{ secrets.GITHUB_TOKEN }}"

      - name: Enable auto-merge for patch updates
        if: steps.metadata.outputs.update-type == 'version-update:semver-patch'
        run: gh pr merge --auto --merge "$PR_URL"
        env:
          PR_URL: ${{ github.event.pull_request.html_url }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
`

	return w.writeFile(".github/workflows/dependabot-auto-merge.yml", content)
}

// writeFile writes content to a file relative to project root.
func (w *WorkflowGenerator) writeFile(filename, content string) error {
	fullPath := filepath.Join(w.projectRoot, filename)

	// Create directory if it doesn't exist
	if err := os.MkdirAll(filepath.Dir(fullPath), 0755); err != nil {
		return fmt.Errorf("failed to create directory for %s: %w", filename, err)
	}

	// Write file
	if err := os.WriteFile(fullPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write %s: %w", filename, err)
	}

	w.logger.Debug("Generated file: %s", filename)
	return nil
}

// GetEcosystemForPlatform returns the Dependabot ecosystem for a given platform.
func GetEcosystemForPlatform(platform string) string {
	platform = strings.ToLower(platform)
	if ecosystem, ok := platformToEcosystem[platform]; ok {
		return ecosystem
	}
	return ""
}
