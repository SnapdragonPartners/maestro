package architect

import (
	"time"
)

//go:generate stringer -type=ArchitectState -trimprefix=State

// IMPORTANT: This file is the canonical implementation of the architect FSM
// and must always be kept in sync with pkg/architect/STATES.md.
// Any changes to this file require explicit human permission and must
// be accompanied by corresponding updates to the state diagram.
// This is the single source of truth for all architect state transitions.

// ArchitectState represents the canonical state of an architect agent
// This enum is derived directly from STATES.md and serves as the single source of truth
type ArchitectState int

const (
	// Entry state
	StateWaiting ArchitectState = iota

	// Spec intake states
	StateScoping

	// Story dispatch states
	StateDispatching

	// Main event loop states
	StateMonitoring
	StateRequest

	// Human escalation states
	StateEscalated

	// Merge & unblock states
	StateMerging

	// Terminal states
	StateDone
	StateError
)

// String method will be auto-generated by stringer tool

// architectTransitions defines the canonical state transition map for architect agents.
// This is the single source of truth, derived directly from STATES.md.
// Any code, tests, or diagrams must match this specification exactly.
var architectTransitions = map[ArchitectState][]ArchitectState{
	// WAITING can transition to SCOPING when spec received
	StateWaiting: {StateScoping},

	// SCOPING can transition to DISPATCHING when stories queued, or ERROR on unrecoverable error
	StateScoping: {StateDispatching, StateError},

	// DISPATCHING can transition to MONITORING when stories placed on work-queue, or DONE when no stories left
	StateDispatching: {StateMonitoring, StateDone},

	// MONITORING can transition to REQUEST for any coder request, or MERGING when approved code-review arrives
	StateMonitoring: {StateRequest, StateMerging},

	// REQUEST can transition to MONITORING (approve non-code/request changes), MERGING (approve code-review),
	// ESCALATED (cannot answer), or ERROR (abandon/unrecoverable)
	StateRequest: {StateMonitoring, StateMerging, StateEscalated, StateError},

	// ESCALATED can transition to REQUEST when human answer supplied, or ERROR on timeout/no answer
	StateEscalated: {StateRequest, StateError},

	// MERGING can transition to DISPATCHING when merge succeeds (may unblock more stories), or ERROR on failure
	StateMerging: {StateDispatching, StateError},

	// DONE can transition to WAITING when new spec arrives
	StateDone: {StateWaiting},

	// ERROR can transition to WAITING on recovery/restart
	StateError: {StateWaiting},
}

// ValidNextStates returns the allowed next states for a given ArchitectState
// This is the preferred way to access transition information
func ValidNextStates(from ArchitectState) []ArchitectState {
	return architectTransitions[from]
}

// IsValidArchitectTransition checks if a transition between two states is allowed
// according to the canonical state machine specification from STATES.md
func IsValidArchitectTransition(from, to ArchitectState) bool {
	allowedStates := ValidNextStates(from)
	for _, state := range allowedStates {
		if state == to {
			return true
		}
	}
	return false
}

// EscalationTimeout defines the maximum time an architect can remain in ESCALATED state
// before automatically transitioning to ERROR state
const EscalationTimeout = 2 * time.Hour

// HeartbeatInterval defines the interval for heartbeat debug logging in idle states
const HeartbeatInterval = 30 * time.Second

// DispatcherSendTimeout defines the timeout for dispatcher send operations
const DispatcherSendTimeout = 500 * time.Millisecond

// GetAllArchitectStates returns all valid architect states in deterministic order
func GetAllArchitectStates() []ArchitectState {
	return []ArchitectState{
		StateWaiting,
		StateScoping,
		StateDispatching,
		StateMonitoring,
		StateRequest,
		StateEscalated,
		StateMerging,
		StateDone,
		StateError,
	}
}

// IsTerminalState returns true if the state is a terminal state (DONE or ERROR)
func IsTerminalState(state ArchitectState) bool {
	return state == StateDone || state == StateError
}

// IsValidArchitectState checks if a given state is a valid architect state
func IsValidArchitectState(state ArchitectState) bool {
	allStates := GetAllArchitectStates()
	for _, validState := range allStates {
		if validState == state {
			return true
		}
	}
	return false
}
